.version 6.5
.target sm_30
.address_size 64

.func (.reg .u32 result) get_byte(.reg .u32 input, .reg .u32 i)
{
    mul.lo.u32      i, i, 8;
    .reg .u32       left_shift_amount;
    sub.u32         left_shift_amount, 24, i;
    shl.b32         input, input, left_shift_amount;
    add.u32         i, i, left_shift_amount;
    shr.b32         input, input, i;
    mov.u32         result, input;
    ret;
}


.entry bfe(
	.param .u64 input,
    .param .u64 count_param,
	.param .u64 output
)
{
	.reg .u64 	    in_addr;
	.reg .u64 	    count;
    .reg .u64 	    out_addr;
	ld.param.u64 	in_addr, [input];
	ld.param.u64 	count, [count_param];
    ld.param.u64 	out_addr, [output];

    .reg .u32       tid_x;
    .reg .u32       ntid_x;
    .reg .u32       ctaid_x;
    .reg .u32       nctaid_x;
    .reg .u32       global_id;
    .reg .u64       global_id_64;
    .reg .u64       global_size;
    mov.u32         tid_x, %tid.x;
    mov.u32         ntid_x, %ntid.x;
    mov.u32         ctaid_x, %ctaid.x;
    mov.u32         nctaid_x, %nctaid.x;
    mad.lo.u32      global_id, ntid_x, ctaid_x, tid_x;
    cvt.u64.u32     global_id_64, global_id;
    mul.wide.u32    global_size, ntid_x, nctaid_x;
    .reg .u64       out_offset;
    mul.lo.u64      out_offset, global_id_64, count;
    mad.lo.u64      out_addr, out_offset, <TYPE_SIZE>, out_addr;

    .reg .u32       len;
    call (len), get_byte, (global_id, 0);
    .reg .u32       pos;
    call (pos), get_byte, (global_id, 1);

    .reg .u64       i;
    mov.u64         i, 0;
    .reg .pred      loop_cont;

loop:
    .reg .<TYPE>    value;
    .reg .<TYPE>    result;
    ld.<TYPE>       value, [in_addr];
    bfe.<TYPE>      result, value, pos, len;
    st.<TYPE>       [out_addr], result;
    add.u64         i, i, 1;
    setp.lt.u64     loop_cont, i, count;
    add.u64         in_addr, in_addr, <TYPE_SIZE>;
    add.u64         out_addr, out_addr, <TYPE_SIZE>;
    @loop_cont      bra loop;

	ret;
}
